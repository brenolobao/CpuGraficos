<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Análise de Processadores AMD AM4</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 10px;
            background-color: #f4f4f4;
            color: #333;
            box-sizing: border-box;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .container {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            background: #fff;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            box-sizing: border-box;
            flex-grow: 1;
        }
        h1, h2 {
            text-align: center;
            color: #0056b3;
            margin-top: 15px;
            margin-bottom: 5px;
        }
        h1 {
            font-size: 1.8em;
        }
        h2 {
            font-size: 1.4em;
        }
        .chart-count, .filter-count {
            text-align: center;
            font-size: 0.9em;
            color: #666;
            margin-bottom: 15px;
        }
        .filter-section {
            text-align: center;
            margin-bottom: 25px;
            padding: 10px;
            background-color: #e9ecef;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .filter-section label {
            font-weight: bold;
            margin-right: 0;
            margin-bottom: 5px;
        }
        .filter-section select,
        .filter-section button {
            width: 100%;
            max-width: 300px;
            margin: 0 auto;
            padding: 10px 12px;
            border-radius: 4px;
            border: 1px solid #ccc;
            font-size: 1em;
            cursor: pointer;
            box-sizing: border-box;
            margin-top: 5px;
        }
        .filter-section button {
            margin-left: 0;
            margin-top: 10px;
        }
        .filter-section .download-button {
            background-color: #28a745;
            color: white;
            border: none;
        }
        .filter-section .download-button:hover {
            background-color: #218838;
        }

        /* Carousel Styles */
        .cpu-carousel-container {
            position: relative;
            width: 100%;
            margin: 20px auto;
            overflow: hidden;
            padding: 10px 0; /* Add padding for buttons to show */
            background-color: #f9f9f9;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .cpu-carousel {
            display: flex;
            overflow-x: scroll;
            scroll-snap-type: x mandatory;
            -webkit-overflow-scrolling: touch;
            scroll-behavior: smooth;
            scrollbar-width: none; /* For Firefox */
            -ms-overflow-style: none; /* For Internet Explorer and Edge */
        }
        .cpu-carousel::-webkit-scrollbar {
            display: none; /* For Chrome, Safari, and Opera */
        }
        .cpu-card {
            flex: 0 0 auto; /* Prevent cards from shrinking */
            width: 280px; /* Fixed width for cards */
            margin: 10px;
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            text-align: left;
            scroll-snap-align: start;
        }
        .cpu-card h3 {
            color: #0056b3;
            margin-top: 0;
            margin-bottom: 10px;
            text-align: center;
            font-size: 1.2em;
        }
        .cpu-card p {
            margin: 5px 0;
            font-size: 0.9em;
        }
        .cpu-card .notes {
            display: flex;
            justify-content: space-around;
            margin-top: 15px;
            border-top: 1px solid #eee;
            padding-top: 10px;
        }
        .cpu-card .note-item {
            text-align: center;
            flex: 1;
        }
        .cpu-card .note-item strong {
            display: block;
            font-size: 1.1em;
            color: #28a745;
        }
        .cpu-card .note-item span {
            font-size: 0.75em;
            color: #666;
        }
        .carousel-button {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            padding: 10px 15px;
            cursor: pointer;
            z-index: 100;
            font-size: 1.5em;
            border-radius: 5px;
        }
        .carousel-button:hover {
            background-color: rgba(0, 0, 0, 0.7);
        }
        .carousel-button.prev {
            left: 5px;
        }
        .carousel-button.next {
            right: 5px;
        }

        .chart-container {
            margin-bottom: 30px;
            padding: 15px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            position: relative;
            overflow-x: auto;
        }

        .chart-container canvas {
            max-height: 400px;
            width: 100% !important;
            height: auto !important;
        }

        .chart-comment {
            margin-top: 15px;
            padding: 10px;
            background-color: #e2f0cb;
            border-left: 5px solid #7cb342;
            border-radius: 4px;
            font-size: 0.85em;
        }
        .no-data {
            text-align: center;
            font-size: 1.1em;
            color: #666;
            padding: 30px;
        }

        /* Media Queries for larger screens (e.g., tablets and desktops) */
        @media (min-width: 768px) {
            body {
                padding: 20px;
            }
            .container {
                padding: 20px;
            }
            h1 {
                font-size: 2.5em;
            }
            h2 {
                font-size: 1.7em;
            }
            .filter-section {
                flex-direction: row;
                justify-content: center;
                align-items: center;
                gap: 15px;
                padding: 15px;
            }
            .filter-section label {
                margin-bottom: 0;
                margin-right: 10px;
            }
            .filter-section select,
            .filter-section button {
                width: auto;
                margin: 0;
            }
            .filter-section button {
                margin-top: 0;
                margin-left: 10px;
            }
            .chart-comment {
                font-size: 0.9em;
            }
            .no-data {
                font-size: 1.2em;
                padding: 50px;
            }
            .chart-container canvas {
                max-height: 500px;
            }
            .cpu-card {
                width: 300px; /* Slightly wider cards on larger screens */
            }
            .carousel-button {
                padding: 12px 18px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Análise de Processadores AMD AM4 (2017-2025)</h1>

        <div class="filter-section">
            <label for="threadsFilter">Filtrar por número de Threads:</label>
            <select id="threadsFilter">
                <option value="">Selecione o número de Threads</option>
            </select>
            <label for="manufacturerFilter">Filtrar por Fabricante:</label>
            <select id="manufacturerFilter">
                <option value="all">Todos</option>
            </select>
            <button onclick="applyFilter()">Aplicar Filtro</button>
            <button onclick="resetFilter()">Limpar Filtro</button>
            <button onclick="downloadAllChartsAsImages()" class="download-button">Baixar Imagens dos Gráficos</button>
            <div id="totalCpuCount" class="filter-count"></div>
        </div>

        <div id="cpu-carousel-container" class="cpu-carousel-container">
            <h2>Processadores Destacados (Desempenho e Custo-Benefício)</h2>
            <div id="cpu-carousel" class="cpu-carousel">
                </div>
            <button class="carousel-button prev" onclick="scrollCarousel(-1)">&#10094;</button>
            <button class="carousel-button next" onclick="scrollCarousel(1)">&#10095;</button>
        </div>


        <div id="chart-area">
            <div class="no-data">Selecione o número de Threads para exibir os gráficos.</div>
        </div>

        <hr>
        <div class="chart-container">
            <h2>Relação Desempenho/Preço de Lançamento (Todos os CPUs com Dados Completos)</h2>
            <div id="overallPerfPriceCount" class="chart-count"></div>
            <canvas id="overallPerfPriceChart"></canvas>
            <div id="overallPerfPriceComment" class="chart-comment"></div>
        </div>
    </div>

    <script>
        let allProcessors = [];
        let singleCoreChart, multiCoreChart, litographyChart, priceChart, perfPriceChart, overallPerfPriceChart;
        const GITHUB_LINK = "github.com/brenolobao"; // Seu link do GitHub

        async function fetchData() {
            try {
                const response = await fetch('cpusAmd-2017-2025-am4.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                allProcessors = data.processadores;

                const totalProcessorsWithPerfData = allProcessors.filter(p =>
                    p.desempenho && p.desempenho.single_core !== null && p.desempenho.multi_core !== null
                );
                document.getElementById('totalCpuCount').textContent = `Total de CPUs com dados de desempenho: ${totalProcessorsWithPerfData.length}`;

                populateThreadsFilter(allProcessors);
                populateManufacturerFilter(allProcessors); // Populate the new manufacturer filter
                document.getElementById('chart-area').innerHTML = '<div class="no-data">Selecione o número de Threads para exibir os gráficos.</div>';
                drawOverallPerfPriceChart(allProcessors); // Draw this chart initially
                displayAllCpuCards(); // Display all CPU cards in the carousel
            } catch (error) {
                console.error('Erro ao carregar os dados dos processadores:', error);
                document.getElementById('chart-area').innerHTML = '<div class="no-data" style="color: red;">Erro ao carregar os dados. Verifique se o arquivo cpusAmd-2017-2025-am4.json está na mesma pasta.</div>';
                document.getElementById('totalCpuCount').textContent = 'Erro ao carregar dados.';
                document.getElementById('overallPerfPriceComment').innerHTML = '<div class="no-data" style="color: red;">Erro ao carregar dados para este gráfico.</div>';
                document.getElementById('cpu-carousel').innerHTML = '<div class="no-data" style="color: red;">Erro ao carregar dados para os cartões de CPU.</div>';
            }
        }

        function populateThreadsFilter(processors) {
            const threadsSet = new Set(processors.map(p => p.threads).filter(t => t !== null));
            const sortedThreads = Array.from(threadsSet).sort((a, b) => a - b);
            const select = document.getElementById('threadsFilter');
            select.innerHTML = '<option value="">Selecione o número de Threads</option>';
            sortedThreads.forEach(threads => {
                const option = document.createElement('option');
                option.value = threads;
                option.textContent = threads + ' Threads';
                select.appendChild(option);
            });
        }

        function populateManufacturerFilter(processors) {
            const manufacturerSet = new Set(processors.map(p => p.fabricante).filter(f => f !== null));
            const sortedManufacturers = Array.from(manufacturerSet).sort();
            const select = document.getElementById('manufacturerFilter');
            select.innerHTML = '<option value="all">Todos</option>'; // Default option
            sortedManufacturers.forEach(manufacturer => {
                const option = document.createElement('option');
                option.value = manufacturer;
                option.textContent = manufacturer;
                select.appendChild(option);
            });
        }

        function applyFilter() {
            const selectedThreads = document.getElementById('threadsFilter').value;
            const selectedManufacturer = document.getElementById('manufacturerFilter').value;

            let filteredProcessors = allProcessors;

            if (selectedThreads) {
                filteredProcessors = filteredProcessors.filter(p => p.threads == parseInt(selectedThreads));
            }

            if (selectedManufacturer && selectedManufacturer !== 'all') {
                filteredProcessors = filteredProcessors.filter(p => p.fabricante === selectedManufacturer);
            }

            if (filteredProcessors.length === 0) {
                document.getElementById('chart-area').innerHTML = '<div class="no-data">Nenhum processador encontrado para os filtros selecionados.</div>';
                destroyCharts();
                return;
            }

            destroyCharts();
            displayCharts(filteredProcessors);
        }

        function resetFilter() {
            document.getElementById('threadsFilter').value = '';
            document.getElementById('manufacturerFilter').value = 'all'; // Reset manufacturer filter
            document.getElementById('chart-area').innerHTML = '<div class="no-data">Selecione o número de Threads e/ou Fabricante para exibir os gráficos.</div>';
            destroyCharts();
        }

        function destroyCharts() {
            if (singleCoreChart) { singleCoreChart.destroy(); singleCoreChart = null; }
            if (multiCoreChart) { multiCoreChart.destroy(); multiCoreChart = null; }
            if (litographyChart) { litographyChart.destroy(); litographyChart = null; }
            if (priceChart) { priceChart.destroy(); priceChart = null; }
            if (perfPriceChart) { perfPriceChart.destroy(); perfPriceChart = null; }
        }

        function displayCharts(processors) {
            const chartArea = document.getElementById('chart-area');
            chartArea.innerHTML = `
                <hr>
                <div class="chart-container">
                    <h2>Desempenho Single-Core (Crescente)</h2>
                    <div id="singleCoreCount" class="chart-count"></div>
                    <canvas id="singleCoreChart"></canvas>
                    <div id="singleCoreComment" class="chart-comment"></div>
                </div>

                <hr>
                <div class="chart-container">
                    <h2>Desempenho Multi-Core (Crescente)</h2>
                    <div id="multiCoreCount" class="chart-count"></div>
                    <canvas id="multiCoreChart"></canvas>
                    <div id="multiCoreComment" class="chart-comment"></div>
                </div>

                <hr>
                <div class="chart-container">
                    <h2>Média de Desempenho por Litografia</h2>
                    <div id="litographyCount" class="chart-count"></div>
                    <canvas id="litographyChart"></canvas>
                </div>

                <hr>
                <div class="chart-container">
                    <h2>Preço de Lançamento por Ano (Crescente)</h2>
                    <div id="priceCount" class="chart-count"></div>
                    <canvas id="priceChart"></canvas>
                    <div id="priceComment" class="chart-comment"></div>
                </div>

                <hr>
                <div class="chart-container">
                    <h2>Relação Desempenho/Preço de Lançamento (Crescente)</h2>
                    <div id="perfPriceCount" class="chart-count"></div>
                    <canvas id="perfPriceChart"></canvas>
                    <div id="perfPriceComment" class="chart-comment"></div>
                </div>
            `;

            drawSingleCoreChart(processors);
            drawMultiCoreChart(processors);
            drawLitographyChart(processors);
            drawPriceChart(processors);
            drawPerfPriceChart(processors);
        }

        const commonChartOptions = {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    title: {
                        display: true,
                        text: 'Pontuação'
                    }
                },
                x: {
                    title: {
                        display: true,
                        text: 'Processador'
                    },
                    ticks: {
                        autoSkip: true,
                        maxRotation: 90,
                        minRotation: 0
                    }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            return `${context.dataset.label}: ${context.raw}`;
                        }
                    }
                }
            }
        };

        function drawSingleCoreChart(processors) {
            const validProcessors = processors.filter(p => p.desempenho && p.desempenho.single_core !== null);
            validProcessors.sort((a, b) => a.desempenho.single_core - b.desempenho.single_core);

            document.getElementById('singleCoreCount').textContent = `CPUs exibidos: ${validProcessors.length}`;

            const labels = validProcessors.map(p => p.nome);
            const data = validProcessors.map(p => p.desempenho.single_core);

            const ctx = document.getElementById('singleCoreChart').getContext('2d');
            singleCoreChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Pontuação Single-Core',
                        data: data,
                        backgroundColor: 'rgba(75, 192, 192, 0.6)',
                        borderColor: 'rgba(75, 192, 192, 1)',
                        borderWidth: 1
                    }]
                },
                options: commonChartOptions
            });

            let largestConsecutiveDiff = 0;
            let worst = validProcessors.length > 0 ? validProcessors[0].desempenho.single_core : 0;
            let best = validProcessors.length > 0 ? validProcessors[validProcessors.length - 1].desempenho.single_core : 0;

            for (let i = 0; i < validProcessors.length - 1; i++) {
                const current = validProcessors[i].desempenho.single_core;
                const next = validProcessors[i + 1].desempenho.single_core;
                if (current > 0) {
                    const diff = ((next - current) / current) * 100;
                    if (diff > largestConsecutiveDiff) {
                        largestConsecutiveDiff = diff;
                    }
                }
            }

            let worstToBestDiff = 0;
            if (worst > 0) {
                worstToBestDiff = ((best - worst) / worst) * 100;
            }

            const commentDiv = document.getElementById('singleCoreComment');
            commentDiv.innerHTML = `
                Maior percentual de aumento entre CPUs consecutivos: <strong>${largestConsecutiveDiff.toFixed(2)}%</strong>.<br>
                Percentual de aumento do pior para o melhor: <strong>${worstToBestDiff.toFixed(2)}%</strong>.
            `;
            if (validProcessors.length < 2) {
                commentDiv.innerHTML = "Não há dados suficientes para calcular percentuais de comparação.";
            }
        }

        function drawMultiCoreChart(processors) {
            const validProcessors = processors.filter(p => p.desempenho && p.desempenho.multi_core !== null);
            validProcessors.sort((a, b) => a.desempenho.multi_core - b.desempenho.multi_core);

            document.getElementById('multiCoreCount').textContent = `CPUs exibidos: ${validProcessors.length}`;

            const labels = validProcessors.map(p => p.nome);
            const data = validProcessors.map(p => p.desempenho.multi_core);

            const ctx = document.getElementById('multiCoreChart').getContext('2d');
            multiCoreChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Pontuação Multi-Core',
                        data: data,
                        backgroundColor: 'rgba(153, 102, 255, 0.6)',
                        borderColor: 'rgba(153, 102, 255, 1)',
                        borderWidth: 1
                    }]
                },
                options: commonChartOptions
            });

            let largestConsecutiveDiff = 0;
            let worst = validProcessors.length > 0 ? validProcessors[0].desempenho.multi_core : 0;
            let best = validProcessors.length > 0 ? validProcessors[validProcessors.length - 1].desempenho.multi_core : 0;

            for (let i = 0; i < validProcessors.length - 1; i++) {
                const current = validProcessors[i].desempenho.multi_core;
                const next = validProcessors[i + 1].desempenho.multi_core;
                if (current > 0) {
                    const diff = ((next - current) / current) * 100;
                    if (diff > largestConsecutiveDiff) {
                        largestConsecutiveDiff = diff;
                    }
                }
            }

            let worstToBestDiff = 0;
            if (worst > 0) {
                worstToBestDiff = ((best - worst) / worst) * 100;
            }

            const commentDiv = document.getElementById('multiCoreComment');
            commentDiv.innerHTML = `
                Maior percentual de aumento entre CPUs consecutivos: <strong>${largestConsecutiveDiff.toFixed(2)}%</strong>.<br>
                Percentual de aumento do pior para o melhor: <strong>${worstToBestDiff.toFixed(2)}%</strong>.
            `;
            if (validProcessors.length < 2) {
                commentDiv.innerHTML = "Não há dados suficientes para calcular percentuais de comparação.";
            }
        }

        function drawLitographyChart(processors) {
            const litographyData = {};

            const validProcessorsForLitho = processors.filter(p => p.litografia && p.desempenho && p.desempenho.single_core !== null && p.desempenho.multi_core !== null);

            validProcessorsForLitho.forEach(p => {
                if (!litographyData[p.litografia]) {
                    litographyData[p.litografia] = { singleSum: 0, multiSum: 0, count: 0 };
                }
                litographyData[p.litografia].singleSum += p.desempenho.single_core;
                litographyData[p.litografia].multiSum += p.desempenho.multi_core;
                litographyData[p.litografia].count++;
            });

            const labels = Object.keys(litographyData).sort((a, b) => parseFloat(a) - parseFloat(b));
            const avgSingleCore = labels.map(lit => litographyData[lit].singleSum / litographyData[lit].count);
            const avgMultiCore = labels.map(lit => litographyData[lit].multiSum / litographyData[lit].count);

            document.getElementById('litographyCount').textContent = `Litografias exibidas: ${labels.length} (com base em ${validProcessorsForLitho.length} CPUs)`;

            const ctx = document.getElementById('litographyChart').getContext('2d');
            litographyChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Média Single-Core',
                            data: avgSingleCore,
                            backgroundColor: 'rgba(255, 99, 132, 0.6)',
                            borderColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'Média Multi-Core',
                            data: avgMultiCore,
                            backgroundColor: 'rgba(54, 162, 235, 0.6)',
                            borderColor: 'rgba(54, 162, 235, 1)',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    ...commonChartOptions,
                    scales: {
                        y: {
                            ...commonChartOptions.scales.y,
                            title: {
                                display: true,
                                text: 'Pontuação Média'
                            }
                        },
                        x: {
                            ...commonChartOptions.scales.x,
                            title: {
                                display: true,
                                text: 'Litografia (nm)'
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: ${context.raw.toFixed(2)}`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function drawPriceChart(processors) {
            const validProcessors = processors.filter(p => p.preco_lancamento !== null && p.preco_lancamento !== undefined && p.preco_lancamento > 0 && p.data_lancamento);

            validProcessors.sort((a, b) => {
                const [monthA, yearA] = a.data_lancamento.split('/').map(Number);
                const [monthB, yearB] = b.data_lancamento.split('/').map(Number);

                if (yearA !== yearB) {
                    return yearA - yearB;
                }
                return monthA - monthB;
            });

            document.getElementById('priceCount').textContent = `CPUs exibidos: ${validProcessors.length}`;

            const labels = validProcessors.map(p => `${p.nome} (${p.data_lancamento})`);
            const data = validProcessors.map(p => p.preco_lancamento);

            const ctx = document.getElementById('priceChart').getContext('2d');
            priceChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Preço de Lançamento (USD)',
                        data: data,
                        backgroundColor: 'rgba(255, 206, 86, 0.6)',
                        borderColor: 'rgba(255, 206, 86, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    ...commonChartOptions,
                    scales: {
                        y: {
                            ...commonChartOptions.scales.y,
                            title: {
                                display: true,
                                text: 'Preço (USD)'
                            }
                        },
                        x: {
                            ...commonChartOptions.scales.x,
                            title: {
                                display: true,
                                text: 'Processador (Data de Lançamento)'
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: $${context.raw.toFixed(2)}`;
                                }
                            }
                        }
                    }
                }
            });

            const commentDiv = document.getElementById('priceComment');
            if (validProcessors.length === 0) {
                 commentDiv.innerHTML = 'Não há dados de preço de lançamento disponíveis para exibir este gráfico para os filtros selecionados.';
            } else {
                 commentDiv.innerHTML = 'Este gráfico exibe o preço de lançamento de cada processador, ordenado cronologicamente por ano de lançamento.';
            }
        }

        function drawPerfPriceChart(processors) {
            const validProcessors = processors.filter(p =>
                p.preco_lancamento !== null && p.preco_lancamento !== undefined && p.preco_lancamento > 0 &&
                p.desempenho && p.desempenho.single_core !== null && p.desempenho.multi_core !== null
            );

            const perfPriceRatios = validProcessors.map(p => {
                const performance = (p.desempenho.single_core + p.desempenho.multi_core) / 2;
                return {
                    name: p.nome,
                    ratio: performance / p.preco_lancamento,
                    originalPrice: p.preco_lancamento,
                    originalSingle: p.desempenho.single_core,
                    originalMulti: p.desempenho.multi_core
                };
            });

            perfPriceRatios.sort((a, b) => a.ratio - b.ratio);

            document.getElementById('perfPriceCount').textContent = `CPUs exibidos: ${perfPriceRatios.length}`;

            const labels = perfPriceRatios.map(p => p.name);
            const data = perfPriceRatios.map(p => p.ratio);

            const ctx = document.getElementById('perfPriceChart').getContext('2d');
            perfPriceChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Desempenho/Preço (Pontos/USD)',
                        data: data,
                        backgroundColor: 'rgba(75, 192, 192, 0.6)',
                        borderColor: 'rgba(75, 192, 192, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    ...commonChartOptions,
                     scales: {
                        y: {
                            ...commonChartOptions.scales.y,
                            title: {
                                display: true,
                                text: 'Relação Desempenho/Preço'
                            }
                        },
                        x: {
                            ...commonChartOptions.scales.x,
                            title: {
                                display: true,
                                text: 'Processador'
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const item = perfPriceRatios[context.dataIndex];
                                    return `Relação: ${item.ratio.toFixed(2)} | Preço: $${item.originalPrice.toFixed(2)} | SC: ${item.originalSingle} | MC: ${item.originalMulti}`;
                                }
                            }
                        }
                    }
                }
            });

            const commentDiv = document.getElementById('perfPriceComment');
            if (perfPriceRatios.length > 0) {
                const bestPerfPrice = perfPriceRatios[perfPriceRatios.length - 1];
                const worstPerfPrice = perfPriceRatios[0];
                commentDiv.innerHTML = `
                    Processador com melhor relação desempenho/preço: <strong>${bestPerfPrice.name}</strong> (Relação: ${bestPerfPrice.ratio.toFixed(2)}).<br>
                    Processador com pior relação desempenho/preço: <strong>${worstPerfPrice.name}</strong> (Relação: ${worstPerfPrice.ratio.toFixed(2)}).
                `;
            } else {
                commentDiv.innerHTML = 'Não há dados suficientes (preço de lançamento e desempenho) para calcular a relação desempenho/preço.';
            }
        }

        function drawOverallPerfPriceChart(processors) {
            const validProcessors = processors.filter(p =>
                p.preco_lancamento !== null && p.preco_lancamento !== undefined && p.preco_lancamento > 0 &&
                p.desempenho && p.desempenho.single_core !== null && p.desempenho.multi_core !== null
            );

            const perfPriceRatios = validProcessors.map(p => {
                const performance = (p.desempenho.single_core + p.desempenho.multi_core) / 2;
                return {
                    name: p.nome,
                    ratio: performance / p.preco_lancamento,
                    originalPrice: p.preco_lancamento,
                    originalSingle: p.desempenho.single_core,
                    originalMulti: p.desempenho.multi_core
                };
            });

            perfPriceRatios.sort((a, b) => a.ratio - b.ratio);

            document.getElementById('overallPerfPriceCount').textContent = `CPUs exibidos: ${perfPriceRatios.length}`;

            const labels = perfPriceRatios.map(p => p.name);
            const data = perfPriceRatios.map(p => p.ratio);

            const ctx = document.getElementById('overallPerfPriceChart').getContext('2d');
            if (overallPerfPriceChart) {
                overallPerfPriceChart.destroy();
            }
            overallPerfPriceChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Desempenho/Preço (Pontos/USD)',
                        data: data,
                        backgroundColor: 'rgba(255, 159, 64, 0.6)',
                        borderColor: 'rgba(255, 159, 64, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    ...commonChartOptions,
                    scales: {
                        y: {
                            ...commonChartOptions.scales.y,
                            title: {
                                display: true,
                                text: 'Relação Desempenho/Preço'
                            }
                        },
                        x: {
                            ...commonChartOptions.scales.x,
                            title: {
                                display: true,
                                text: 'Processador'
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const item = perfPriceRatios[context.dataIndex];
                                    return `Relação: ${item.ratio.toFixed(2)} | Preço: $${item.originalPrice.toFixed(2)} | SC: ${item.originalSingle} | MC: ${item.originalMulti}`;
                                }
                            }
                        }
                    }
                }
            });

            const commentDiv = document.getElementById('overallPerfPriceComment');
            if (perfPriceRatios.length > 0) {
                const bestOverallPerfPrice = perfPriceRatios[perfPriceRatios.length - 1];
                const worstOverallPerfPrice = perfPriceRatios[0];
                commentDiv.innerHTML = `
                    **Melhor** relação desempenho/preço (Geral): <strong>${bestOverallPerfPrice.name}</strong> (Relação: ${bestOverallPerfPrice.ratio.toFixed(2)}).<br>
                    **Pior** relação desempenho/preço (Geral): <strong>${worstOverallPerfPrice.name}</strong> (Relação: ${worstOverallPerfPrice.ratio.toFixed(2)}).
                `;
            } else {
                commentDiv.innerHTML = 'Não há dados suficientes (preço de lançamento e desempenho) para calcular a relação desempenho/preço para todos os processadores.';
            }
        }

        // Função para adicionar marca d'água
        function addWatermarkToCanvas(canvas, text) {
            const ctx = canvas.getContext('2d');
            const originalWidth = canvas.width;
            const originalHeight = canvas.height;

            ctx.save(); // Save the current canvas state

            ctx.font = '20px Arial'; // Adjust font size as needed
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)'; // Darker color, semi-transparent
            ctx.textAlign = 'right';
            ctx.textBaseline = 'bottom';

            // Measure text width to ensure it fits
            const textWidth = ctx.measureText(text).width;
            const padding = 20; // Padding from the right and bottom edges

            // Ensure text does not go out of bounds
            let x = originalWidth - padding;
            let y = originalHeight - padding;

            ctx.fillText(text, x, y);

            ctx.restore(); // Restore the canvas state
        }


        function downloadAllChartsAsImages() {
            const selectedThreads = document.getElementById('threadsFilter').value;
            const selectedManufacturer = document.getElementById('manufacturerFilter').value;

            const threadSuffix = selectedThreads ? `_${selectedThreads}_Threads` : '';
            const manufacturerSuffix = (selectedManufacturer && selectedManufacturer !== 'all') ? `_${selectedManufacturer}` : '';


            const chartsToDownload = [
                { chart: singleCoreChart, id: 'singleCoreChart', name: 'Desempenho_SingleCore', usesFilter: true },
                { chart: multiCoreChart, id: 'multiCoreChart', name: 'Desempenho_MultiCore', usesFilter: true },
                { chart: litographyChart, id: 'litographyChart', name: 'Desempenho_Litografia', usesFilter: true },
                { chart: priceChart, id: 'priceChart', name: 'Preco_Lancamento', usesFilter: true },
                { chart: perfPriceChart, id: 'perfPriceChart', name: 'Relacao_Desempenho_Preco_Filtrado', usesFilter: true },
                { chart: overallPerfPriceChart, id: 'overallPerfPriceChart', name: 'Relacao_Desempenho_Preco_Geral', usesFilter: false }
            ];

            chartsToDownload.forEach(chartInfo => {
                const canvas = document.getElementById(chartInfo.id);
                if (canvas && canvas.offsetParent !== null) {
                    // Create a temporary canvas to draw the image and watermark
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = canvas.width;
                    tempCanvas.height = canvas.height;
                    const tempCtx = tempCanvas.getContext('2d');

                    // Draw the chart image onto the temporary canvas
                    tempCtx.drawImage(canvas, 0, 0);

                    // Add the watermark
                    addWatermarkToCanvas(tempCanvas, GITHUB_LINK);

                    const image = tempCanvas.toDataURL('image/png');
                    const link = document.createElement('a');

                    const fileName = chartInfo.usesFilter ? `${chartInfo.name}${threadSuffix}${manufacturerSuffix}.png` : `${chartInfo.name}.png`;

                    link.href = image;
                    link.download = fileName;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                }
            });
        }

        function calculatePerformanceScore(processor, allProcessors) {
            if (!processor.desempenho || processor.desempenho.single_core === null || processor.desempenho.multi_core === null) {
                return 0;
            }
            // Use a weighted average if desired, or a simple average
            const performance = (processor.desempenho.single_core * 0.4) + (processor.desempenho.multi_core * 0.6); // Example weighting

            const allPerformances = allProcessors
                .filter(p => p.desempenho && p.desempenho.single_core !== null && p.desempenho.multi_core !== null)
                .map(p => (p.desempenho.single_core * 0.4) + (p.desempenho.multi_core * 0.6));

            const maxPerformance = Math.max(...allPerformances);
            return maxPerformance > 0 ? (performance / maxPerformance) * 10 : 0;
        }

        function calculateValueScore(processor, allProcessors) {
            if (!processor.preco_lancamento || processor.preco_lancamento <= 0 || !processor.desempenho || processor.desempenho.single_core === null || processor.desempenho.multi_core === null) {
                return 0;
            }
            const performance = (processor.desempenho.single_core * 0.4) + (processor.desempenho.multi_core * 0.6); // Consistent performance metric
            const valueRatio = performance / processor.preco_lancamento;

            const allValueRatios = allProcessors
                .filter(p => p.preco_lancamento && p.preco_lancamento > 0 && p.desempenho && p.desempenho.single_core !== null && p.desempenho.multi_core !== null)
                .map(p => (((p.desempenho.single_core * 0.4) + (p.desempenho.multi_core * 0.6)) / p.preco_lancamento));

            const maxValueRatio = Math.max(...allValueRatios);
            return maxValueRatio > 0 ? (valueRatio / maxValueRatio) * 10 : 0;
        }

        function displayAllCpuCards() {
            const carousel = document.getElementById('cpu-carousel');
            carousel.innerHTML = ''; // Clear previous cards

            const selectedManufacturer = document.getElementById('manufacturerFilter').value;

            let eligibleProcessors = allProcessors.filter(p =>
                p.preco_lancamento !== null && p.preco_lancamento !== undefined && p.preco_lancamento > 0 &&
                p.desempenho && p.desempenho.single_core !== null && p.desempenho.multi_core !== null &&
                p.nucleos !== null && p.threads !== null && p.data_lancamento && p.fabricante
            );

            if (selectedManufacturer && selectedManufacturer !== 'all') {
                eligibleProcessors = eligibleProcessors.filter(p => p.fabricante === selectedManufacturer);
            }


            // Sort by performance score in descending order for better display in carousel
            eligibleProcessors.sort((a, b) => calculatePerformanceScore(b, allProcessors) - calculatePerformanceScore(a, allProcessors));


            if (eligibleProcessors.length === 0) {
                carousel.innerHTML = '<div class="no-data">Nenhum processador com dados completos de desempenho e preço para exibir no carousel com os filtros selecionados.</div>';
                return;
            }

            eligibleProcessors.forEach(cpu => {
                const performanceScore = calculatePerformanceScore(cpu, allProcessors).toFixed(1);
                const valueScore = calculateValueScore(cpu, allProcessors).toFixed(1);
                const year = cpu.data_lancamento ? cpu.data_lancamento.split('/')[1] : 'N/A';

                const card = `
                    <div class="cpu-card">
                        <h3>${cpu.nome}</h3>
                        <p><strong>Fabricante:</strong> ${cpu.fabricante}</p>
                        <p><strong>Núcleos/Threads:</strong> ${cpu.nucleos}/${cpu.threads}</p>
                        <p><strong>Ano de Lançamento:</strong> ${year}</p>
                        <p><strong>Preço de Lançamento:</strong> $${cpu.preco_lancamento.toFixed(2)}</p>
                        <div class="notes">
                            <div class="note-item">
                                <strong>${performanceScore}</strong>
                                <span>Desempenho Bruto</span>
                            </div>
                            <div class="note-item">
                                <strong>${valueScore}</strong>
                                <span>Custo-Benefício</span>
                            </div>
                        </div>
                    </div>
                `;
                carousel.innerHTML += card;
            });
        }

        function scrollCarousel(direction) {
            const carousel = document.getElementById('cpu-carousel');
            const cardWidth = document.querySelector('.cpu-card').offsetWidth; // Get width of one card
            const scrollAmount = cardWidth + 20; // Card width + margin

            carousel.scrollBy({
                left: direction * scrollAmount,
                behavior: 'smooth'
            });
        }


        document.addEventListener('DOMContentLoaded', fetchData);
    </script>
</body>
</html>
